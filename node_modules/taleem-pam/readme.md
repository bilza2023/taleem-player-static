
# Plain App Model (PAM)

Plain App Model (PAM) is a minimal architectural pattern for building app-like
web pages using **plain HTML and JavaScript**.

PAM is **not a framework**.
It is a small set of rules and primitives for managing **state, time, and rendering**
explicitly and predictably.

---

## Core Idea

* State lives at the top level
* Time comes from an external clock (which can be replaced by audio clocks like Howler)
* A single render loop exists and drives rendering
* Rendering is explicit and deterministic

There is no hidden lifecycle, no virtual DOM, and no implicit state.

---

## API Overview

### State

You own the state object.

```js
state
```

---

### Passive Clock (`Timer`)

```js
timer.play()
timer.pause()
timer.seek(t)
timer.now()
```

The clock is external and replaceable.

---

### Render Loop

```js
renderLoop.setDraw(drawFn)
renderLoop.start(loopFn)
renderLoop.draw(state)
```

Only **one render loop** exists.
Rendering is always driven by explicit state.

---

### Draw Function

```js
function draw(state) {
  // deterministic rendering
}
```

---

## Complete Copy-Paste Demo (Recommended)

Below is a **fully working PAM app** in a single HTML file.

It includes:

* External clock (`Timer`)
* Single eternal render loop
* Play / stop controls
* Scrubbable timeline
* Explicit state + deterministic rendering

This example is intentionally **clear rather than minimal**.

You can copy this file, open it in a browser, and start experimenting.

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>PAM â€“ Minimal Example</title>

  <style>
    body {
      margin: 0;
      height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: system-ui, sans-serif;
    }

    #time {
      font-size: 6rem;
      font-weight: 800;
      margin-bottom: 2rem;
    }

    .controls {
      display: flex;
      gap: 1rem;
      align-items: center;
    }

    input[type="range"] {
      width: 300px;
    }
  </style>
</head>

<body>

  <div id="time">0.0</div>

  <div class="controls">
    <button id="play-btn">Play</button>
    <button id="stop-btn">Stop</button>
    <input id="scrub" type="range" min="0" max="30" step="0.1" />
  </div>

  <script type="module">
    import { renderLoop, Timer } from "taleem-pam"

    const state = {
      currentTime: 0,
      duration: 30
    }

    const timer = new Timer()

    const timeEl  = document.getElementById("time")
    const playBtn = document.getElementById("play-btn")
    const stopBtn = document.getElementById("stop-btn")
    const scrubEl = document.getElementById("scrub")

    scrubEl.min = 0
    scrubEl.max = state.duration
    scrubEl.step = 0.1

    function draw(state) {
      const t = state.currentTime
      timeEl.textContent = t.toFixed(1)
      scrubEl.value = t
    }

    renderLoop.setDraw(draw)

    state.currentTime = timer.now()
    scrubEl.value = state.currentTime

    renderLoop.start(() => {
      state.currentTime = timer.now()
      renderLoop.draw(state)
    })

    playBtn.onclick = () => {
      timer.play()
    }

    stopBtn.onclick = () => {
      timer.pause()
      timer.seek(0)
    }

    scrubEl.oninput = e => {
      timer.seek(+e.target.value)
      timer.pause()
    }
  </script>

</body>
</html>
```

---

## Philosophy

PAM embraces:

* Explicit state
* Explicit time
* Explicit rendering
* Zero magic

If you want a framework, PAM is not for you.
If you want **full control with minimal primitives**, PAM stays out of your way.

For a deeper explanation of **why PAM exists** and the problems it is designed to solve, see  
[WHY_PAM.md](./docs/WHY_PAM.md).  
It explains the mismatch between reactive UI frameworks and time-driven, app-like pages, and how PAM reduces the problem to explicit **state, time, and drawing**.
